JAVA面试题（三）——GC
===

垃圾回收机制（GC）：该机制对JVM（java虚拟内存）中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动地回收内存，防止出现内存泄漏和内存溢出。

- java内存区域

  1. 程序计数器
  2. 虚拟机栈：存储基本数据类型，以及对象的引用，私有线程
  3. 本地方法栈
  4. 堆区：存放对象实例与数组
  5. 方法区：主要存储（类加载器）ClassLoader加载的类信息，存储包括类的元数据，常量池，字段，静态变量与方法内的局部变量以及编译好的字节码，等等

- 哪些内存需要回收

  1. 可达性分析法：这个算法的基本思想是通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链（即GC Roots到对象不可达）时，则证明此对象是不可用的。

     - 在Java语言中，可以作为GCRoots的对象包括下面几种：

       (1). 虚拟机栈（栈帧中的局部变量区，也叫做局部变量表）中引用的对象。

       (2). 方法区中的类静态属性引用的对象。

       (3). 方法区中常量引用的对象。

       (4). 本地方法栈中JNI(Native方法)引用的对象。

  2. 四大引用

     - 强引用：类似"Object obj = new Object()"这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。

     - 软引用：描述有些还有用但并非必需的对象。在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围进行二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。Java中的类SoftReference表示软引用。

     - 弱引用：描述非必需对象。被弱引用关联的对象只能生存到下一次垃圾回收之前，垃圾收集器工作之后，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。Java中的类WeakReference表示弱引用。

     - 虚引用：这个引用存在的唯一目的就是在这个对象被收集器回收时收到一个系统通知，被虚引用关联的对象，和其生存时间完全没关系。Java中的类PhantomReference表示虚引用。

       ![四大引用](https://images2015.cnblogs.com/blog/249993/201703/249993-20170306195851516-1068507269.png)

  3. 方法区的垃圾回收

     - 废弃常量
     - 无用的类：
       1. 该类的所有实例都已经被回收，即Java堆中不存在该类的任何实例。
       2. 加载该类的ClassLoader已经被回收。
       3. 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

- 内存泄漏and溢出

  - 内存溢出：指程序在申请内存时，没有足够的内存空间供其使用 。
    - 原因：
      1. 内存中加载的数据量过于庞大，如一次从数据库取出过多数据； 
      2. 集合类中有对对象的引用，使用完后未清空，使得JVM不能回收； 
      3. 代码中存在死循环或循环产生过多重复的对象实体； 
      4. 使用的第三方软件中的BUG； 
      5. 启动参数内存值设定的过小
    - 解决方案：
      1. 增加JVM内存大小
      2. 优化程序，释放垃圾：避免死循环、防止一次载入太多数据、及时释放无用对象等。
  - 内存泄漏：程序在申请内存后，无法释放已申请的内存空间。
    - 类别
      1. 常发性
      2. 偶发性
      3. 一次性
      4. 隐式
    - 发生场景
      1. 静态集合类引起的内存泄漏
         - 像**HashMap、Vector**等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。
      2. 当集合里面的**对象属性被修改**后，再调用remove（）方法时不起作用。
      3. 监听器
         - 在java 编程中，我们都需要和监听器打交道，通常一个应用当中会用到很多监听器，我们会调用一个控件的诸如addXXXListener()等方法来增加监听器，但往往在释放对象的时候却没有记住去删除这些监听器，从而增加了内存泄漏的机会。
      4. 各种连接
         - 比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。
         - 对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。
         - 但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。
         - 这种情况下一般都会在try里面去的连接，在finally里面释放连接。
      5. 单例模式
         - 单例对象在被初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部对象的引用，那么这个外部对象将不能被jvm正常回收，导致内存泄露
    - 检查工具：LeakCanary
    - 解决方案：
      1. 释放无用变量的引用
      2. 避免使用String，改用StringBuffer
      3. 避免使用静态变量
      4. 避免集中创建大对象