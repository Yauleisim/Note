八大排序
===

1. 冒泡排序

   - 它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。
   - 这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 

```c
	
   for (int i = 0;i < n - 1;i++)
   {
           for (int j = 0;j < n - 1 - i;j++)
           {
               if(a[j] > a[j + 1])
               {
                   swap();		//交换位置
               }
           }
   }
```
   

   - 时间复杂度：
		- 平均、最坏：O（n^2）
		- 最好：O（n）
   	- 空间复杂度（辅助存储）：O（1）
  	- 稳定性：稳定
   	- 改进版一：设置一标志性变量pos,用于记录每趟排序中最后一次进行交换的位置。由于pos位置之后的记录均已交换到位,故在进行下一趟排序时只要扫描到pos位置即可。 

```c
   void Bubble_1 ( int r[], int n) {  
       int i = n -1;  //初始时,最后位置保持不变  
       while ( i > 0) {   
           int pos= 0; //每趟开始时,无记录交换  
           for (int j = 0; j< i; j++)  
               if (r[j]> r[j+1]) {  
                   pos= j; //记录交换的位置   
                   int tmp = r[j]; r[j]=r[j+1];r[j+1]=tmp;  
               }   
           i= pos; //为下一趟排序作准备  
        }   
   }    
   
```

   - 改进版二：若某一趟排序中未进行一次交换，则排序结束 。

```java
   public static void bubbleSort(int[] array) {
       int len = array.length;
       boolean flag = true;
       while (flag) {
           flag = false;
           for (int i = 0; i < len - 1; i++) {
               if (array[i] > array[i + 1]) {
                   int temp = array[i + 1];
                   array[i + 1] = array[j];
                   array[i] = temp;
                   flag = true;
               }
           }
           len--;
       }
   }
```

   

2. 选择排序

   - 每趟选出未排序中最大/小的那个数。

   - 步骤：
		- 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
		- 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
		- 重复上述步骤，直到所有元素均排序完毕。

     ```c
     void select_sort(int a[],int n)
     {
         int i,j,min,t;
         for(i = 0;i < n-1;i++)
         {
             min = i;//查找最小值
             for(j = i + 1;j < n;j++)
                 if(a[min] > a[j])
                     min = j;
             if(min != i)
             {//交换
                 t = a[min];
                 a[min] = a[i];
                 a[i] = t;
             }
         }
     }
     ```
   - 时间复杂度
		- 平均、最优、最差：O（n^2）

   - 空间复杂度（辅助空间）：O（1）

   - 稳定性：不稳定

3. 直接插入排序：

   - 每步将一个待排序序列按数据大小插到前面已经排序的序列中的适当位置（从后往前扫描），直到全部数据插入完毕为止。 
   - 如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。

```c
   void insert_sort(int array[],int n)
   {
       int i,j;
       int temp;
       for(i = 1;i < n;i++)
       {
           temp = array[i];
           for(j = i;j > 0&& array[j - 1] > temp;j--)
           {
               array[j]= array[j - 1];
           }
           array[j] = temp;
       }
   }
```

   - 时间复杂度:
		- 平均、最坏：O（n^2）
		- 最好：O（n）
   - 空间复杂度（辅助存储）：O（1）
   - 稳定性：稳定

4. 希尔排序（缩小增量排序）：

   - 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。

   - 步骤：
		- 选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
		- 按增量序列个数k，对序列进行k 趟排序；
		- 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。
		- 仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。
![希尔排序实例](http://my.csdn.net/uploads/201207/18/1342577299_5077.jpg)
   - 时间复杂度：
		- 平均：O（n^1.3）(无结论)
		- 最好：O（n）
		- 最坏：O（n^2）
   - 空间复杂度（辅助存储）：O（1）
   - 稳定性：不稳定

5. 二分插入排序：

   - 与直接插入的不同点在于不是从后往前扫描而是在插入时与有序序列的中间值进行比较
   - 时间复杂度：
		- 最差、平均：O（n^2）
		- 最优：O（nlogn）
   - 空间复杂度：O（1）
   - 稳定性：稳定

6. 归并排序

   - 归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。
![归并排序实例](http://my.csdn.net/uploads/201207/21/1342842633_6751.jpg)

   - 时间复杂度
		- 最优、平均、最差：O（nlogn）

   - 空间复杂度（辅助存储）：O（n）

   - 稳定性：稳定

7. 快速排序

	- 在序列中挑选出一个元素作为基准，把所有比他小的放前面，比他大的放后面，再对分区递归进行这些操作。

	- 步骤：
		- 选择一个基准元素,通常选择第一个元素或者最后一个元素
		- 通过一趟排序将待排序的记录分割成独立的两部分，其中一部分记录的元素值均比基准元素值小。另一部分记录的元素值比基准值大。
		- 此时基准元素在其排好序后的正确位置
		- 然后分别对这两部分记录用同样的方法继续进行排序，直到整个序列有序。

     ```java
     public static void quickSort(int[] array, int left, int right) {
         if (left < right) {
             int pivot = array[left];		//基准元素
             int low = left;
             int high = right;
             while (low < high) {
                 while (low < high && array[high] >= pivot) {
                     high--;
                 }
                 array[low] = array[high];	//小的放前面
                 while (low < high && array[low] <= pivot) {
                     low++;
                 }
                 array[high] = array[low];	//大的放后面
             }
             array[low] = pivot;
             //分区递归调用
             quickSort(array, left, low - 1);		
             quickSort(array, low + 1, right);
         }
     }
     ```
	- 时间复杂度：
		- 平均、最好：O（nlogn）
		- 最差：O（n^2）

   - 空间复杂度（辅助存储）：O（nlogn）

   - 稳定性：不稳定

8. 堆排序：

   - 堆分为大根堆和小根堆，是完全二叉树。
   - 大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] >= A[i]，小根堆则相反。 
   - 堆排序利用了大根堆（或小根堆）堆顶记录的关键字最大（或最小）这一特征，使得在当前无序区中选取最大（或最小）关键字的记录变得简单。 
   - 用大根堆排序的基本思想 
		- 先将初始数组建成一个大根堆，此堆为初始的无序区 
		- 再将最大的元素（即堆顶）和无序区的最后一个记录交换，由此得到新的无序区和有序区。 
		- 由于交换后新的根可能违反堆性质，故应将当前无序区调整为堆。然后再次将中最大的元素和该区间的最后一个记录交换，由此得到新的无序区和有序区，同样要将调整为堆。
		- 直到无序区只有一个元素为止。 
   - 时间复杂度：
		- 平均、最好、最差：O（nlogn）
   - 空间复杂度：O（1）
   - 稳定性：不稳定

   

   